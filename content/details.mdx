### Scale to zero

When a Neon compute endpoint hasn't received any connections for a specified amount of time, it can [autosuspend](https://neon.tech/docs/introduction/auto-suspend).
This is useful for:

-  **Resource Management** - Turning off unused databases is automatic.
- **Cost-Efficiency** - Never pay for compute that's not serving queries.

But scale to zero is only useful if compute can start up quickly again when it's needed. That's why cold start times are so important.

### Applications of scale to zero

Look at the cold start times documented above and decide: _In what scenarios is the occasional `~550ms` delay acceptable?_

The answer depends on the specifics of your project.
Here are some example scenarios where scale to zero may be useful:

- **Non-Production Databases** - Development, preview, staging, test databases.
- **Internal Apps** - If the userbase for your app is a limited number of employees, the db is likely idle more than active.
- **Database-per-user Architectures** - Instead of having a single database for all users, if you have a separate database for each user, the activity level of any one database may be low enough that scale to zero results in significant cost reduction.
- **Small Projects** - For small projects, configuring the production database to scale to zero can make it more cost-efficient without major impact to UX.

---

## Benchmark methodology

To gather real-world cold start times, the benchmark uses a Neon project with a separate [database branch](https://neon.tech/docs/introduction/branching) for each of the above variants. A [serverless function](https://github.com/ruf-io/neon-cold-start/blob/main/setup/index.js) executes the following steps every 30 minutes:

1. Check that the database is autosuspended
2. Connect and execute a SQL query on the database, forcing it to start.
3. Log the total response time from before connection create to after response received.
4. Suspend the database.

### Calculating Results

The cold start duration for every benchmark run is saved in a table.
To calculate the results, results are fetched and the [`simple-statistics`](https://simple-statistics.github.io/) library is used to calculate P50, P99, and Standard Deviation of results.

The code where the results are calculated can be found [here](https://github.com/ruf-io/neon-cold-start/blob/main/hooks/index.tsx#L126-L134).

### Benchmark Code

All code for the benchmark and display of results is available [on GitHub](https://github.com/ruf-io/neon-cold-start/blob/main/setup/index.js) Here is a snippet showing how the timing of the cold start is measured:

```javascript
// Run benchmark
const before = new Date(); // <-- Start Timer Here
const benchmarkPool = new Pool({
  host: benchmarkEndpoint.host,
  password: benchmarkRolePassword,
  user: ROLE_NAME,
  database: DATABASE_NAME,
  ssl: true,
});

await benchmarkPool.query(benchmarkQuery);
const after = new Date(); // <-- End Timer Here
const benchmarkValue = after.getTime() - before.getTime();
benchmarkPool.end();
```

### Benchmark Specifications

<dl>
    <dt>Database Compute Size:</dt>
    <dd>0.25 CU (0.25 vCPU, 1GB RAM)</dd>
    <dt>Database Region:</dt>
    <dd>AWS US-East-2 (Ohio)</dd>
    <dt>Lambda Region:</dt>
    <dd>AWS US-East-2 (Ohio)</dd>
    <dt>Postgres Connection Type:</dt>
    <dd><a href="https://neon.tech/docs/connect/connection-pooling">Pooled</a> <em>(Testing shows no significant difference between pooled vs unpooled)</em></dd>
    <dt>Postgres Version:</dt>
    <dd>PostgreSQL 16</dd>
    <dt>Postgres Driver:</dt>
    <dd><a href="https://node-postgres.com/">node-postgres</a></dd>

</dl>



## Try It Yourself

Sign up for the [free Neon account](https://neon.tech), clone the repo for this benchmark and website: [Neon Cold Start Repo](https://github.com/ruf-io/neon-cold-start) and you can run and modify the benchmarks yourself.
Follow the developer docs in the repo to get started.

Keep in mind that benchmarks run locally will include the roundtrip latency from your device to AWS datacenter. The cold starts from this page are deployed in a Lambda in the same AWS region as the Neon database.

---

#### Credits

Special thanks to [`joacoc`](https://github.com/joacoc) for writing the benchmark logic.